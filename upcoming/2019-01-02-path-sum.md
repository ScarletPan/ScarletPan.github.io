---
layout: post
title: Path Sum
categories: Algorithm
comments: true
description: leetcode
keywords: path
---

本文介绍Path Sum及其扩展。

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

## 1. 问题及其子问题
### 1.1 基础问题引入
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
```
Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```

* **解决思路1：递归**
<br> 当root为叶子节点的时候判断其值是否等于sum，如果是非叶子节点则判断左右子树是否有pathSum。由于节点可能为负，故不能再某一非叶节点就停止。所以时间复杂度为遍历整棵树，即$O(N)$。

    ```c++
    class Solution {
    public:
        bool hasPathSum(TreeNode* root, int sum) {
            if (!root) return false;
            return (root->val == sum && !root->left && !root->right) 
                || hasPathSum(root->left, sum - root->val) 
                || hasPathSum(root->right, sum - root->val);
        }
    };
    ```

* **解决思路2：非递归（辅助栈）**
<br> 需要注意的是我们需要一个另一个辅助栈来维护遍历到某个节点时刻所要计算的sum是什么。
```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        stack<TreeNode*> stk;
        stack<int> sums;
        stk.push(root);
        sums.push(sum);
        while (!stk.empty()) {
            TreeNode* node = stk.top(); stk.pop();
            int cur_sum = sums.top(); sums.pop();
            if (cur_sum == node->val && !node->left && !node->right)
                return true;
            if (node->right) {
                stk.push(node->right);
                sums.push(cur_sum - node->val);
            }
            if (node->left) {
                stk.push(node->left);
                sums.push(cur_sum - node->val);
            }
        }
        return false;
    }
};
```

### 1.2 输出所有满足条件的路径
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
```
Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1

[
   [5,4,11,2],
   [5,8,4,5]
]
```
* **解决思路1：递归**
<br> 此时需要输出所有满足要求的路径，故需要遍历整棵树，即去掉或 ||。
    ```c++
    class Solution {
    public:
        vector<vector<int>> pathSum(TreeNode* root, int sum) {
            vector<vector<int>> res;
            get_pathSum(root, sum, res, {});
            return res;
        }
        
        void get_pathSum(TreeNode* root, int sum, vector<vector<int>> &res, vector<int> path) {
            if (!root) return;
            path.push_back(root->val);
            if (root->val == sum && !root->left && !root->right) {
                res.push_back(path);
                return;
            }
            get_pathSum(root->left, sum - root->val, res, path);
            get_pathSum(root->right, sum - root->val, res, path);
        }
    };
    ```

### 1.3 初始节点可以不是root，目标节点可以不是leaf
You are given a binary tree in which each node contains an integer value.
Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```
* **解决思路1：两层递归**
<br> 两层递归，首先是遍历每一个节点，计算这个节点为初始节点时候有多少符合条件的path，在计算path的时候再进行递归，把所有的情况都遍历出来。时间复杂度为$O(N^2)$。
    ```c++
    class Solution {
    public:
        int pathSum(TreeNode* root, int sum) {
            if (!root) return 0;
            return pathCount(root, sum) +
                pathSum(root->left, sum) +
                pathSum(root->right, sum);
        }

        int pathCount(TreeNode* root, int sum) {
            if (!root) return 0;
            return int(root->val == sum) +
                pathCount(root->left, sum - root->val) +
                pathCount(root->right, sum - root->val); 
        }
    };
    ```
* **解决思路2：哈希表存储prePathSum**
<br>前序遍历节点，在遍历下层节点的时候，保存上层节点所有的pathSum的个数，在回溯的时候再将相应的pathSum减去。时间复杂度为$O(N)$，最差空间复杂度为 $O(N^2)$ （考虑输入为增序的二叉搜索树，每个节点间的path都不相同）
    ```c++
    class Solution {
    public:
        int pathSum(TreeNode* root, int sum) {
            map<int, int> h;
            return helper(root, 0, sum, h);
        }

        int helper(TreeNode* root, int preSum, int target, map<int, int>& h) {
            if (!root) return 0;
            int curSum = preSum + root->val;
            int res = 0;
            if (h.find(curSum - target) != h.end())
                res += h[curSum - target];
            h[curSum]++;
            res += helper(root->left, curSum, target, h) +
                helper(root->right, curSum, target, h);
            h[curSum]--;
            return res;
        }
    };
    ```

<br>
<br>

## 2. 相关问题
### 2.1 Longest Univalue Path

Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.
```
              5
             / \
            4   5
           / \   \
          1   1   5

Output 2
```
* **解决思路1：两次遍历**
<br> 分别对root，以及左右两个子节点查找最长路径，然后比较，存在重复遍历的现象。
    ```c++
    class Solution {
    public:
        int longestUnivaluePath(TreeNode* root) {
            if (!root) return 0;
            int res = getMaxPathLength(root->left, root->val) + 
                        getMaxPathLength(root->right, root->val);
            if (root->left)
                res = max(res, longestUnivaluePath(root->left));
            if (root->right)
                res = max(res, longestUnivaluePath(root->right));
            return res;
        }

        int getMaxPathLength(TreeNode* root, int val) {
            if (!root) return 0;
            if (root->val == val) {
                return max(getMaxPathLength(root->left, val), 
                            getMaxPathLength(root->right, val));
            }
            return 0;
        }
    };
    ```
* **解决思路2：一次遍历**
<br> 即在查找单边最长路径的时候同时也记录子节点中的longestUnivaluePath
    ```
    class Solution {
    public:
        int longestUnivaluePath(TreeNode* root) {
            if (!root) return 0;
            int res = 0;
            helper(root, res);
            return res;
        }

        int helper(TreeNode* root, int &res) {
            int lt = root->left ? helper(root->left, res): 0;
            int rt = root->right ? helper(root->right, res): 0;
            int lt_val = root->left && root->left->val == root->val ? lt + 1: 0;
            int rt_val = root->right && root->right->val == root->val ? rt + 1: 0;
            res = max(res, lt_val + rt_val);
            return max(lt_val, rt_val);
        }
    };
    ```
